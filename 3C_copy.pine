// @version=5
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿
// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⣿⣿⡛⠛⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⠟⠛⠛⠛⠉⠉⠉⠁⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠙⠛⣻⣿⣿
// ⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣾⣿⣿⣿
// ⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿
// ⣿⣿⣏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣷⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⣷⣦⣤⣀⡀⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
// ⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿

// Developer Notes:
// @LastUpdated 06-22-2025T3:00:00Z
// @Version 2.0.0
// @Description A sophisticated RSI indicator enhanced with machine learning, advanced filtering, and dynamic signal generation.
// @Author zen silva
// @OriginalAuthor BullVisionCapital
// @License Mozilla Public License 2.0
// @Website https://imacl.one

// @Changelog:
// - Major performance optimizations
// - Enhanced feature extraction with market context
// - Adaptive machine learning with KNN
// - Advanced filtering options (Adaptive Kalman, Hull MA, Gaussian)
// - Dynamic signal generation with confirmation
// - Divergence detection
// - Improved visualization with dynamic colors and prediction bands

// @Note:
// This script is designed for educational purposes and should not be considered financial advice.
indicator("MLRSIv2", shorttitle="MLRSIv2", overlay=false)

// ===== Constants =====
var int MAX_ARRAY_SIZE = 500
var float EPSILON = 0.0001

// ===== Input Parameters =====
group_rsi = "RSI Configuration"
rsiLength = input.int(14, "RSI Period", minval=2, maxval=50, group=group_rsi)
srcInput = input.source(close, "Source", group=group_rsi)

group_ml = "Machine Learning Settings"
enableML = input.bool(true, "Enable ML Enhancement", group=group_ml)
kNeighbors = input.int(7, "K Neighbors", minval=3, maxval=15, group=group_ml)
lookbackPeriod = input.int(120, "ML Lookback", minval=50, maxval=300, group=group_ml)
mlWeight = input.float(0.5, "ML Blend Weight", minval=0.0, maxval=1.0, step=0.05, group=group_ml)
adaptiveFeatures = input.bool(true, "Adaptive Feature Selection", group=group_ml)

group_signals = "Signal Generation"
generateSignals = input.bool(true, "Generate Buy/Sell Signals", group=group_signals)
signalSensitivity = input.float(2.0, "Signal Sensitivity", minval=0.5, maxval=5.0, step=0.1, group=group_signals)
confirmationBars = input.int(2, "Confirmation Bars", minval=1, maxval=5, group=group_signals)

group_filter = "Advanced Filtering"
filterType = input.string("Adaptive Kalman", "Filter Type", options=["None", "Adaptive Kalman", "Hull MA", "Gaussian"], group=group_filter)
adaptiveStrength = input.bool(true, "Adaptive Filter Strength", group=group_filter)

group_visual = "Visual Settings"
showDivergence = input.bool(true, "Show Divergences", group=group_visual)
showPredictionBand = input.bool(true, "Show Prediction Band", group=group_visual)
colorIntensity = input.string("Dynamic", "Color Mode", options=["Static", "Dynamic", "Gradient"], group=group_visual)

// ===== Core Functions =====

// Optimized RSI calculation with momentum
rsi_with_momentum(src, len) =>
    var float up_sum = 0.0
    var float down_sum = 0.0
    var int init_complete = 0
    
    change = src - src[1]
    up = math.max(change, 0)
    down = math.max(-change, 0)
    
    if bar_index < len
        up_sum := up_sum + up
        down_sum := down_sum + down
        init_complete := init_complete + 1
    else
        up_sum := up_sum - (up_sum / len) + up
        down_sum := down_sum - (down_sum / len) + down
    
    rs = down_sum == 0 ? 100 : up_sum / down_sum
    rsi = 100 - (100 / (1 + rs))
    momentum = change / src[1] * 100
    
    [rsi, momentum]

// Feature extraction with market context
extract_features(rsi_val, src, lookback) =>
    // Core features
    f1 = rsi_val / 100.0  // Normalized RSI
    f2 = (rsi_val - ta.sma(rsi_val, 10)) / 50.0  // RSI deviation
    f3 = ta.stdev(rsi_val, 10) / 20.0  // RSI volatility
    
    // Price-based features
    f4 = (src - ta.sma(src, 20)) / ta.stdev(src, 20)  // Price z-score
    f5 = (src - src[5]) / src[5]  // 5-bar momentum
    
    // Volume features (if available)
    f6 = na(volume) ? 0.5 : (volume - ta.sma(volume, 20)) / ta.stdev(volume, 20)
    
    // Trend strength
    f7 = ta.linreg(rsi_val, 10, 0) - ta.linreg(rsi_val, 10, 5)
    f7 := f7 / 50.0  // Normalize
    
    // Market regime
    atr = ta.atr(14)
    f8 = atr / ta.sma(atr, 50)  // Relative volatility
    
    features = array.from(f1, f2, f3, f4, f5, f6, f7, f8)
    features

// Optimized KNN with weighted voting
knn_predict(current_features, history_features, history_values, k) =>
    var distances = array.new_float(0)
    var values = array.new_float(0)
    
    array.clear(distances)
    array.clear(values)
    
    history_size = matrix.rows(history_features)
    
    // Calculate distances
    for i = 0 to math.min(history_size - 1, lookbackPeriod - 1)
        hist_feat = matrix.get_row(history_features, i)
        
        // Euclidean distance with feature importance weighting
        dist = 0.0
        feat_size = array.size(current_features)
        
        for j = 0 to feat_size - 1
            curr_val = array.get(current_features, j)
            hist_val = array.get(hist_feat, j)
            
            // Adaptive feature weighting
            weight = adaptiveFeatures ? (j < 3 ? 1.5 : 1.0) : 1.0
            dist := dist + weight * math.pow(curr_val - hist_val, 2)
        
        dist := math.sqrt(dist)
        
        if array.size(distances) < k
            array.push(distances, dist)
            array.push(values, array.get(history_values, i))
        else
            // Keep only k nearest
            max_dist = array.max(distances)
            max_idx = array.indexof(distances, max_dist)
            
            if dist < max_dist
                array.set(distances, max_idx, dist)
                array.set(values, max_idx, array.get(history_values, i))
    
    // Weighted prediction
    prediction = 0.0
    total_weight = 0.0
    confidence = 0.0
    
    if array.size(distances) > 0
        for i = 0 to array.size(distances) - 1
            dist = array.get(distances, i)
            val = array.get(values, i)
            
            // Gaussian kernel weighting
            weight = math.exp(-dist * dist / 2.0)
            prediction := prediction + weight * val
            total_weight := total_weight + weight
        
        prediction := total_weight > 0 ? prediction / total_weight : 50.0
        
        // Calculate prediction confidence
        avg_dist = array.avg(distances)
        confidence := 1.0 / (1.0 + avg_dist)
    else
        prediction := 50.0
        confidence := 0.0
    
    [prediction, confidence]

// Advanced filtering
apply_filter(value, filter_type, adaptive) =>
    filtered = value
    
    if filter_type == "Adaptive Kalman"
        var float x = value
        var float p = 1.0
        
        // Adaptive parameters based on volatility
        volatility = ta.stdev(value, 20)
        q = adaptive ? 0.01 * (1 + volatility / 10) : 0.01
        r = adaptive ? 0.1 * (1 + volatility / 10) : 0.1
        
        // Kalman filter equations
        x := x + q
        p := p + q
        k = p / (p + r)
        x := x + k * (value - x)
        p := (1 - k) * p
        
        filtered := x
        
    else if filter_type == "Hull MA"
        wma1 = ta.wma(value, 4)
        wma2 = ta.wma(value, 8)
        filtered := ta.wma(2 * wma1 - wma2, 3)
        
    else if filter_type == "Gaussian"
        var weights = array.from(0.0625, 0.25, 0.375, 0.25, 0.0625)
        sum_val = 0.0
        sum_weight = 0.0
        
        for i = 0 to 4
            if i <= bar_index
                sum_val := sum_val + value[i] * array.get(weights, i)
                sum_weight := sum_weight + array.get(weights, i)
        
        filtered := sum_val / sum_weight
    
    filtered

// Divergence detection
detect_divergence(price, rsi, lookback) =>
    // Find pivot points
    rsi_pivot_high = ta.pivothigh(rsi, lookback, lookback)
    rsi_pivot_low = ta.pivotlow(rsi, lookback, lookback)
    price_pivot_high = ta.pivothigh(price, lookback, lookback)
    price_pivot_low = ta.pivotlow(price, lookback, lookback)
    
    // Bullish divergence
    bull_div = false
    if not na(rsi_pivot_low) and not na(price_pivot_low)
        prev_rsi_low = ta.valuewhen(not na(rsi_pivot_low), rsi_pivot_low, 1)
        prev_price_low = ta.valuewhen(not na(price_pivot_low), price_pivot_low, 1)
        
        if rsi_pivot_low > prev_rsi_low and price_pivot_low < prev_price_low
            bull_div := true
    
    // Bearish divergence
    bear_div = false
    if not na(rsi_pivot_high) and not na(price_pivot_high)
        prev_rsi_high = ta.valuewhen(not na(rsi_pivot_high), rsi_pivot_high, 1)
        prev_price_high = ta.valuewhen(not na(price_pivot_high), price_pivot_high, 1)
        
        if rsi_pivot_high < prev_rsi_high and price_pivot_high > prev_price_high
            bear_div := true
    
    [bull_div, bear_div]

// ===== Main Calculation =====

// Calculate base RSI with momentum
[base_rsi, momentum] = rsi_with_momentum(srcInput, rsiLength)

// Initialize ML components
var feature_history = matrix.new<float>(0, 8)
var value_history = array.new_float(0)

// Current features
current_features = extract_features(base_rsi, srcInput, lookbackPeriod)

// ML prediction
ml_prediction = base_rsi
prediction_confidence = 0.0

if enableML and bar_index > lookbackPeriod
    [pred, conf] = knn_predict(current_features, feature_history, value_history, kNeighbors)
    ml_prediction := pred
    prediction_confidence := conf

// Blend ML with base RSI
enhanced_rsi = enableML ? base_rsi * (1 - mlWeight) + ml_prediction * mlWeight : base_rsi

// Apply filtering
final_rsi = apply_filter(enhanced_rsi, filterType, adaptiveStrength)

// Update history (with size limit)
if bar_index > 1
    if matrix.rows(feature_history) >= MAX_ARRAY_SIZE
        matrix.remove_row(feature_history, 0)
        array.shift(value_history)
    
    matrix.add_row(feature_history, matrix.rows(feature_history), current_features)
    array.push(value_history, base_rsi[1])

// Dynamic thresholds
volatility = ta.stdev(final_rsi, 50)
overbought = 70 + math.min(volatility * 0.5, 10)
oversold = 30 - math.min(volatility * 0.5, 10)

// Signal generation
long_signal = false
short_signal = false

if generateSignals
    rsi_slope = final_rsi - final_rsi[1]
    
    // Long conditions
    long_cond1 = ta.crossover(final_rsi, oversold)
    long_cond2 = final_rsi < oversold + 5 and rsi_slope > signalSensitivity
    long_cond3 = prediction_confidence > 0.7 and ml_prediction > final_rsi
    
    // Short conditions
    short_cond1 = ta.crossunder(final_rsi, overbought)
    short_cond2 = final_rsi > overbought - 5 and rsi_slope < -signalSensitivity
    short_cond3 = prediction_confidence > 0.7 and ml_prediction < final_rsi
    
    // Confirmation
    long_signal := (long_cond1 or long_cond2 or long_cond3) and 
                   ta.barssince(short_signal[1]) > confirmationBars
    short_signal := (short_cond1 or short_cond2 or short_cond3) and 
                    ta.barssince(long_signal[1]) > confirmationBars

// Divergences
[bull_div, bear_div] = detect_divergence(srcInput, final_rsi, 5)

// ===== Visualization =====

// Color calculation
rsi_color = switch colorIntensity
    "Static" => final_rsi > 50 ? color.new(#00ff99, 0) : color.new(#ff3366, 0)
    "Dynamic" => 
        intensity = math.abs(final_rsi - 50) / 50
        final_rsi > 50 ? color.new(#00ff99, 100 - intensity * 100) : 
                        color.new(#ff3366, 100 - intensity * 100)
    "Gradient" =>
        color.from_gradient(final_rsi, 0, 100, color.new(#ff3366, 0), color.new(#00ff99, 0))

// Main RSI plot
rsi_plot = plot(final_rsi, "Enhanced RSI", rsi_color, 2)

// Prediction band
upper_band = final_rsi + volatility * 0.5
lower_band = final_rsi - volatility * 0.5

if showPredictionBand and enableML
    p1 = plot(upper_band, "Upper Band", color.new(rsi_color, 80), 1)
    p2 = plot(lower_band, "Lower Band", color.new(rsi_color, 80), 1)
    fill(p1, p2, color.new(rsi_color, 90))

// Threshold lines
ob_line = plot(overbought, "Overbought", color.new(#ff3366, 50), 1, plot.style_line)
os_line = plot(oversold, "Oversold", color.new(#00ff99, 50), 1, plot.style_line)
mid_line = plot(50, "Midline", color.new(color.white, 70), 1, plot.style_line)

// Zone fills
fill(ob_line, plot(100), color.new(#ff3366, 90))
fill(os_line, plot(0), color.new(#00ff99, 90))

// Signal markers
plotshape(long_signal, "Long Signal", shape.triangleup, location.bottom, 
          color.new(#00ff99, 0), size=size.small)
plotshape(short_signal, "Short Signal", shape.triangledown, location.top, 
          color.new(#ff3366, 0), size=size.small)

// Divergence markers
if showDivergence
    plotshape(bull_div, "Bullish Divergence", shape.labelup, location.bottom, 
              color.new(#00ff99, 0), text="D", textcolor=color.white, size=size.tiny)
    plotshape(bear_div, "Bearish Divergence", shape.labeldown, location.top, 
              color.new(#ff3366, 0), text="D", textcolor=color.white, size=size.tiny)

// Information table
var table info_table = table.new(position.top_right, 2, 6, bgcolor=#1a1a1a, 
                                  frame_color=#333333, frame_width=1)

if barstate.islast
    table.cell(info_table, 0, 0, "RSI", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 0, str.tostring(final_rsi, "#.#"), 
               text_color=rsi_color, text_size=size.small)
    
    table.cell(info_table, 0, 1, "ML Conf", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 1, str.tostring(prediction_confidence * 100, "#.#") + "%", 
               text_color=color.white, text_size=size.small)
    
    table.cell(info_table, 0, 2, "Momentum", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 2, str.tostring(momentum, "#.##") + "%", 
               text_color=momentum > 0 ? #00ff99 : #ff3366, text_size=size.small)
    
    table.cell(info_table, 0, 3, "Signal", text_color=color.white, text_size=size.small)
    signal_text = long_signal ? "LONG" : short_signal ? "SHORT" : "NEUTRAL"
    signal_color = long_signal ? #00ff99 : short_signal ? #ff3366 : color.gray
    table.cell(info_table, 1, 3, signal_text, text_color=signal_color, text_size=size.small)
    
    table.cell(info_table, 0, 4, "OB/OS", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 4, str.tostring(overbought, "#.#") + "/" + 
               str.tostring(oversold, "#.#"), text_color=color.white, text_size=size.small)
    
    table.cell(info_table, 0, 5, "Volatility", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 5, str.tostring(volatility, "#.#"), 
               text_color=color.white, text_size=size.small)

// Alerts
alertcondition(long_signal, "ML RSI Long Signal", "Enhanced ML RSI generated a long signal")
alertcondition(short_signal, "ML RSI Short Signal", "Enhanced ML RSI generated a short signal")
alertcondition(bull_div, "Bullish Divergence", "Bullish divergence detected")
alertcondition(bear_div, "Bearish Divergence", "Bearish divergence detected")
// ===== End of Script =====
